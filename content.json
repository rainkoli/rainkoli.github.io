{"posts":[{"title":"Test2","text":"1. This is a blog Test First Second 2. Show Text 这是加粗 这是斜体 3. tag","link":"/2023/10/02/Test2/"},{"title":"Hello World","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","link":"/2023/09/30/hello-world/"},{"title":"02 高精度 &amp; 前缀和与差分","text":"1","link":"/2023/10/23/02-%E9%AB%98%E7%B2%BE%E5%BA%A6-%E5%89%8D%E7%BC%80%E5%92%8C%E4%B8%8E%E5%B7%AE%E5%88%86/"},{"title":"03 双指针算法 &amp; 位运算 &amp; 离散化 &amp; 区间合并","text":"1","link":"/2023/10/23/03-%E5%8F%8C%E6%8C%87%E9%92%88%E7%AE%97%E6%B3%95-%E4%BD%8D%E8%BF%90%E7%AE%97-%E7%A6%BB%E6%95%A3%E5%8C%96-%E5%8C%BA%E9%97%B4%E5%90%88%E5%B9%B6/"},{"title":"01 快速排序 &amp; 二分","text":"1","link":"/2023/10/23/01-%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F-%E4%BA%8C%E5%88%86/"},{"title":"04 链表与邻接表 &amp; 栈与队列 &amp; kmp","text":"1. 链表与邻接表：数与图的存储1.1 单链表这里主要讲两种链表。第一个是用数组模拟单链表，第二个是用数组模拟双链表单链表在算法题中用的最多的是邻链表。邻接表其实是n个链表，其最主要的应用是存储数和图双链表用的比较多的就是用来优化某些问题 单链表 head -&gt; ∅ 头节点最开始指向一个空节点head - &gt; x -&gt; x -&gt; ∅ 每次会往里面插入一个新的元素每个点会有两个值，一个值val，指针next 用数组来模拟的话，需要在每个节点定义一个数组（下面用e[N]表示），用来表示某个点的值是多少，以及一个next指针（下面用ne[N]）表示指向下一个（e[N]和ne[N]都是整型的数组）e[N]和ne[N]是用下标关联起来的。比方说，这些节点是存在数组里面的，这些节点都会有一个编号。空节点用-1表示，0号点的值就是e[0]，0号点的next指针就是ne[0] 1.1.1 基本操作初始化1234567891011121314const int N = 100010;//head 表示头节点的下标//e[i] 表示节点i的值//ne[i] 表示节点i的next指针是多少（节点i的下一个位置在什么地方）//idx 指针，表示当前已经用到了哪个点int head, e[N], ne[N], idx;//链表的第一个操作：初始化。保证链表是空的void init(){ head = -1;//前面说过用-1表示空集 idx = 0;//每一个点都没有被分配，从0号开始分配} 插入头节点12345678910//将x插到头节点void add_to_head(int x){ e[idx] = x;//存值，idx指向的是当前可以用的，最新的那个点的下标 ne[idx] = head;//第一步，将要添入的节点指向head所指的那个值 head = idx;//第二步，把head指向所要添入的节点 idx ++ ;//当前这个idx用过了指向下一个位置} 插入中间节点12345678//一般插入。把x这个点插入到下标是k的这个点的后面void add(int k, int x){ e[idx] = x; ne[idx] = ne[k];//目标指针指向该点的下一个位置 ne[k] = idx;//指向该点的指针指向目标指针 idx ++ ;} 删除节点12345//将下标是k的点后面的点删除void remove(int k){ ne[k] = ne[ne[k]];} 1.1.2 例题实现一个单链表，链表初始为空，支持三种操作: (1)向链表头插入一个数; (2)删除第k个插入的数后面的数; (3)在第k个插入的数后插入一个数 现在要对该链表进行M次操作，进行完所有操作后，从头到尾输出整个链表。 注意:题目中第k个插入的数并不是指当前链表的第k个数。例如操作过程中一共插入了n个数，则按照插入的时间顺序，这n个数依次为:第1个插入的数，第2个插入的数，…第n个插入的数。 输入格式第一行包含整数M，表示操作次数。 接下来M行，每行包含一个操作命令，操作命令可能为以下几种:(1)”H x”，表示向链表头插入一个数x。 (2) “D k”，表示删除第k个输入的数后面的数(当k为0时，表示删除头结点)。 (3) “l k x”，表示在第k个输入的数后面插入一个数x(此操作中k均大于0)。 输出格式共一行，将整个链表从头到尾输出。 数据范围1 &lt;= M &lt;= 100000所有操作保证合法。 输入样例: 123456789101110H 9l 1 1D 1D 0H 6I 3 6I 4 5I 4 5I 3 4D 6 输出样例: 16 4 6 5 Answer1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283#include &lt;iostream&gt;using namespace std;const int N = 100010;int head, e[N], ne[N], idx;//head 表示头节点的下标//e[i] 表示节点i的值//ne[i] 表示节点i的next指针是多少（节点i的下一个位置在什么地方）//idx 指针，表示当前已经用到了哪个点//初始化void init(){ head = -1;//前面说过用-1表示空集 idx = 0;//每一个点都没有被分配，从0号开始分配}//将x插到头节点void add_to_head(int x){ e[idx] = x; ne[idx] = head; head = idx; idx ++ ;}//将x插到下标是k的点后面void add(int k, int x){ e[idx] = x; ne[idx] = ne[k]; ne[k] = idx; idx ++ ;}//将下标是k的点后面的点删除void remove(int k){ ne[k] = ne[ne[k]];}int main(){ int m;//m个操作 cin &gt;&gt; m; init(); while (m--) { int k, x; char op; cin &gt;&gt; op;//读入操作 if (op == 'H') { cin &gt;&gt; x;//读入要插入的数 add_to_head(x);//调用下插入头节点的函数 } else if (op == 'D') { cin &gt;&gt; k; if (!k) head = ne[head];//如果下标等于0的话删除头节点 remove(k - 1);//调用删除节点的函数 //下标从0开始，0号点是第一个插入的点，第k个插入的点下标就是k - 1 } else { cin &gt;&gt; k &gt;&gt; x; add(k - 1, x);//调用插入中间节点的函数 } } //遍历输出 for (int i = head; i != -1; i = ne[i]) cout &lt;&lt; e[i] &lt;&lt; ' '; cout &lt;&lt; endl; return 0;} 图示过程 1.1.3 模板123456789101112131415161718192021// head存储链表头，e[]存储节点的值，ne[]存储节点的next指针，idx表示当前用到了哪个节点int head, e[N], ne[N], idx;// 初始化void init(){ head = -1; idx = 0;}// 在链表头插入一个数avoid insert(int a){ e[idx] = a, ne[idx] = head, head = idx ++ ;}// 将头结点删除，需要保证头结点存在void remove(){ head = ne[head];} 1.2 双链表2. 栈与队列：单调队列、单调栈3. kmp","link":"/2023/10/23/%E7%AE%97%E6%B3%95/04-%E9%93%BE%E8%A1%A8%E4%B8%8E%E9%82%BB%E6%8E%A5%E8%A1%A8-%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97-kmp/04-%E9%93%BE%E8%A1%A8%E4%B8%8E%E9%82%BB%E6%8E%A5%E8%A1%A8-%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97-kmp/"}],"tags":[{"name":"test","slug":"test","link":"/tags/test/"},{"name":"tag2","slug":"tag2","link":"/tags/tag2/"},{"name":"基础算法","slug":"基础算法","link":"/tags/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/"},{"name":"数据结构","slug":"数据结构","link":"/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"categories":[{"name":"测试用的","slug":"测试用的","link":"/categories/%E6%B5%8B%E8%AF%95%E7%94%A8%E7%9A%84/"},{"name":"算法","slug":"算法","link":"/categories/%E7%AE%97%E6%B3%95/"}],"pages":[]}