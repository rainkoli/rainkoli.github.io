{"posts":[{"title":"03 双指针算法 &amp; 位运算 &amp; 离散化 &amp; 区间合并","text":"1","link":"/2023/10/23/03-%E5%8F%8C%E6%8C%87%E9%92%88%E7%AE%97%E6%B3%95-%E4%BD%8D%E8%BF%90%E7%AE%97-%E7%A6%BB%E6%95%A3%E5%8C%96-%E5%8C%BA%E9%97%B4%E5%90%88%E5%B9%B6/"},{"title":"01 快速排序 &amp; 二分","text":"1","link":"/2023/10/23/01-%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F-%E4%BA%8C%E5%88%86/"},{"title":"Test2","text":"1. This is a blog Test First Second 2. Show Text 这是加粗 这是斜体 3. tag","link":"/2023/10/02/Test2/"},{"title":"02 高精度 &amp; 前缀和与差分","text":"1","link":"/2023/10/23/02-%E9%AB%98%E7%B2%BE%E5%BA%A6-%E5%89%8D%E7%BC%80%E5%92%8C%E4%B8%8E%E5%B7%AE%E5%88%86/"},{"title":"Hello World","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","link":"/2023/09/30/hello-world/"},{"title":"04 链表与邻接表 &amp; 栈与队列 &amp; kmp","text":"1. 链表与邻接表：数与图的存储1.1 单链表这里主要讲两种链表。第一个是用数组模拟单链表，第二个是用数组模拟双链表单链表在算法题中用的最多的是邻链表。邻接表其实是n个链表，其最主要的应用是存储数和图双链表用的比较多的就是用来优化某些问题 单链表 head -&gt; ∅ 头节点最开始指向一个空节点head - &gt; x -&gt; x -&gt; ∅ 每次会往里面插入一个新的元素每个点会有两个值，一个值val，指针next 用数组来模拟的话，需要在每个节点定义一个数组（下面用e[N]表示），用来表示某个点的值是多少，以及一个next指针（下面用ne[N]）表示指向下一个（e[N]和ne[N]都是整型的数组）e[N]和ne[N]是用下标关联起来的。比方说，这些节点是存在数组里面的，这些节点都会有一个编号。空节点用-1表示，0号点的值就是e[0]，0号点的next指针就是ne[0] 1.1.1 基本操作初始化1234567891011121314const int N = 100010;// head 表示头节点的下标// e[i] 表示节点i的值// ne[i] 表示节点i的next指针是多少（节点i的下一个位置在什么地方）// idx 指针，表示当前已经用到了哪个点int head, e[N], ne[N], idx;// 链表的第一个操作：初始化。保证链表是空的void init(){ head = -1;// 前面说过用-1表示空集 idx = 0;// 每一个点都没有被分配，从0号开始分配} 插入头节点12345678910//将x插到头节点void add_to_head(int x){ e[idx] = x;//存值，idx指向的是当前可以用的，最新的那个点的下标 ne[idx] = head;//第一步，将要添入的节点指向head所指的那个值 head = idx;//第二步，把head指向所要添入的节点 idx ++ ;//当前这个idx用过了指向下一个位置} 插入中间节点12345678//一般插入。把x这个点插入到下标是k的这个点的后面void add(int k, int x){ e[idx] = x; ne[idx] = ne[k];//目标指针指向该点的下一个位置 ne[k] = idx;//指向该点的指针指向目标指针 idx ++ ;} 删除节点12345//将下标是k的点后面的点删除void remove(int k){ ne[k] = ne[ne[k]];} 1.1.2 例题实现一个单链表，链表初始为空，支持三种操作： (1)向链表头插入一个数； (2)删除第k个插入的数后面的数； (3)在第k个插入的数后插入一个数 现在要对该链表进行M次操作，进行完所有操作后，从头到尾输出整个链表。 注意：题目中第k个插入的数并不是指当前链表的第k个数。例如操作过程中一共插入了n个数，则按照插入的时间顺序，这n个数依次为:第1个插入的数，第2个插入的数，…第n个插入的数。 输入格式 第一行包含整数M，表示操作次数。 接下来M行，每行包含一个操作命令，操作命令可能为以下几种:(1)”H x”，表示向链表头插入一个数x。 (2) “D k”，表示删除第k个输入的数后面的数(当k为0时，表示删除头结点)。 (3) “l k x”，表示在第k个输入的数后面插入一个数x(此操作中k均大于0)。 输出格式 共一行，将整个链表从头到尾输出。 数据范围 1 &lt;= M &lt;= 100000所有操作保证合法。 输入样例： 123456789101110H 9l 1 1D 1D 0H 6I 3 6I 4 5I 4 5I 3 4D 6 输出样例： 16 4 6 5 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283#include &lt;iostream&gt;using namespace std;const int N = 100010;int head, e[N], ne[N], idx;//head 表示头节点的下标//e[i] 表示节点i的值//ne[i] 表示节点i的next指针是多少（节点i的下一个位置在什么地方）//idx 指针，表示当前已经用到了哪个点//初始化void init(){ head = -1;//前面说过用-1表示空集 idx = 0;//每一个点都没有被分配，从0号开始分配}//将x插到头节点void add_to_head(int x){ e[idx] = x; ne[idx] = head; head = idx; idx ++ ;}//将x插到下标是k的点后面void add(int k, int x){ e[idx] = x; ne[idx] = ne[k]; ne[k] = idx; idx ++ ;}//将下标是k的点后面的点删除void remove(int k){ ne[k] = ne[ne[k]];}int main(){ int m;//m个操作 cin &gt;&gt; m; init(); while (m--) { int k, x; char op; cin &gt;&gt; op;//读入操作 if (op == 'H') { cin &gt;&gt; x;//读入要插入的数 add_to_head(x);//调用下插入头节点的函数 } else if (op == 'D') { cin &gt;&gt; k; if (!k) head = ne[head];//如果下标等于0的话删除头节点 remove(k - 1);//调用删除节点的函数 //下标从0开始，0号点是第一个插入的点，第k个插入的点下标就是k - 1 } else { cin &gt;&gt; k &gt;&gt; x; add(k - 1, x);//调用插入中间节点的函数 } } //遍历输出 for (int i = head; i != -1; i = ne[i]) cout &lt;&lt; e[i] &lt;&lt; ' '; cout &lt;&lt; endl; return 0;} 1.1.3 模板123456789101112131415161718192021// head存储链表头，e[]存储节点的值，ne[]存储节点的next指针，idx表示当前用到了哪个节点int head, e[N], ne[N], idx;// 初始化void init(){ head = -1; idx = 0;}// 在链表头插入一个数avoid insert(int a){ e[idx] = a, ne[idx] = head, head = idx ++ ;}// 将头结点删除，需要保证头结点存在void remove(){ head = ne[head];} 1.2 双链表1.2.1 基本操作初始化123456789101112131415161718const int N = 100010;// e[N]这个点的值是多少// l[N]存这个点左边每个点是谁// r[N]存这个点右边每个点是谁// 下标是0的点为head，最左边的点// 下标是1的点为tail，最右边的点int m;int e[N], l[N], r[N], idx;// 初始化void init(){ // 0表示左端点，1表示右端点。[]中的0、1，同样等号右边也是左右端点的下标 // 0，1属于边界，不算实质内容 r[0] = 1, l[1] = 0; idx = 2; // 0，1已经被占用了} 插入节点123456789// 在下边是k的点的右侧，插入xvoid add(int k, int x){ e[idx] = x; // e[]存值 r[idx] = r[k]; // x右侧的点指向k右侧的点 l[idx] = k; // x左侧的点指向k l[r[k]] = idx; // k右侧点的左边指向x r[k] = idx; // k右边指向x} 第二次改变方向的时候，由于修改k右边点的左指向时要用到r[k]，所以应先修改 如果要在k的左边插入可以调用add(l[k], x) 删除节点123456// 删除第k个点void remove(int k){ r[l[k]] = r[k]; // 让k左边点的右边指向k右边的点 l[r[k]] = l[k]; // 让k右边点的左边指向k左边的点} 1.2.2 例题实现一个双链表，双链表初始为空，支持5种操作： （1）在最左侧插入一个数； （2）在最右侧插入一个数； （3）将第k个插入的数删除； （4）在第k个插入的数左侧插入一个数； （5）在第k个插入的数右侧插入一个数 现在要对该链表进行M次操作，进行完所有操作后，从左到右输出整个链表。 注意：题目中第k个插入的数并不是指当前链表的第k个数。例如操作过程中一共插入了n个数，则按照插入的时间顺序，这n个数依次为：第1个插入的数，第二个插入的数，…第n个插入的数。 输入格式 第一行包含整数M，表示操作次数 接下来M行，每行包含一个操作命令，操作命令可能为以下几种： （1）”L x”，表示在链表的最左端插入数x。 （2）”R x”，表在链表的最右端插入数x。 （3）”D k”，表示将第k个插入的数删除。 （4）”lL k x”，表示在第k个插入的数左侧插入一个数。 （5）”IR k x”，表示在第k个插入的数右侧插入一个数。 输出格式 共一行，将整个链表从左到右输出。 数据范围 1 &lt;= M &lt;= 10^5^ 所有操作保证合法。 输入样例： 123456789101110R 7D 1L 3IL 2 10D 3IL 2 7L 8R 9IL 4 7IR 2 2 输出样例： 18 7 7 3 2 9 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172#include &lt;iostream&gt;using namespace std;const int N = 100010;int m;int e[N], l[N], r[N], idx;void insert(int a, int x){ e[idx] = x; r[idx] = r[a]; l[idx] = a; l[r[a]] = idx; r[a] = idx; idx ++ ;}void remove(int a){ l[r[a]] = l[a]; r[l[a]] = r[a];}int main(){ cin &gt;&gt; m; r[0] = 1, l[1] = 0; idx = 2; while (m -- ) { string op; cin &gt;&gt; op; int k, x; if (op == &quot;L&quot;) { cin &gt;&gt; x; insert(0, x); // 在下标为0的右边的点1处插入，所以后续的操作下标都+1了 // 同时，因为本来就是再右侧插入点，0不算实质内容，所以是(0, x)。也可以写成 insert(l[0], x)（感觉不太对） } else if (op == &quot;R&quot;) // 要在右端点的位置插入是不是应该在右端点的左边一个点的右侧插入 { cin &gt;&gt; x; insert(l[1], x); } else if (op == &quot;D&quot;) { cin &gt;&gt; k; remove(k + 1); } else if (op == &quot;IL&quot;) { cin &gt;&gt; k &gt;&gt; x; insert(l[k + 1], x); } else { cin &gt;&gt; k &gt;&gt; x; insert(k + 1, x); } } // r[0]中的0代表左端点，那么就是左端点右边第一个点。然后下一轮再输出一个点的右边的点。 // 0，1属于边界，不算实质内容。也就是r[0]虽然有值，但是存的是&quot;0&quot;，右侧的点，实际上0位置上是没有东西的 for (int i = r[0]; i != 1; i = r[i]) cout &lt;&lt; e[i] &lt;&lt; ' '; cout &lt;&lt; endl; return 0;} 对于本题的理解主要还是l[]和r[]，其中存的都是下标，本质上是对下标的运算。还是直接直观的去看这个代码的字面意思（抽象？）好理解些 一些演算o.o 1.2.3 模板12345678910111213141516171819202122232425// e[]表示节点的值，l[]表示节点的左指针，r[]表示节点的右指针，idx表示当前用到了哪个节点int e[N], l[N], r[N], idx;// 初始化void init(){ //0是左端点，1是右端点 r[0] = 1, l[1] = 0; idx = 2;}// 在节点a的右边插入一个数xvoid insert(int a, int x){ e[idx] = x; l[idx] = a, r[idx] = r[a]; l[r[a]] = idx, r[a] = idx ++ ;}// 删除节点avoid remove(int a){ l[r[a]] = l[a]; r[l[a]] = r[a];} 2. 栈与队列：单调队列、单调栈2.1 单调栈2.1.1 模拟栈栈：先进后出 123456789101112131415// tt 栈顶下标int stk[N], tt = 0;// 插入stk[ ++ tt] = x;// 弹出tt -- ;// 判断栈是否为空if (tt &gt; 0) not emptyelse empty// 栈顶stk[tt]; 2.1.2 例题 单调栈的问题一般是给定一个序列，求这个序列当中的每一个数，左边离它最近且比它小的数在什么地方 给定一个长度为N的整数数列，输出每个数左边第一个比它小的数，如果不存在则输出-1 输入格式 第一行包含整数N，表示数列长度。 第二行包含N个整数，表示整数数列。 输出格式 共一行，包含N个整数，其中第i个数表示第i个数打的左边第一个比它小的数，如果不存在则输出-1 数据范围 1 &lt;= N &lt;= 10^5^1 &lt;= 数列中元素 &lt;= 10^9^ 输入样例： 1253 4 2 7 5 输出样例： 1-1 3 -1 2 2 1234567891011121314151617181920212223242526272829303132333435#include &lt;iostream&gt;using namespace std;const int N = 100010;int n;int stk[N], tt = 0;int main(){ cin &gt;&gt; n; for (int i = 0; i &lt; n; i ++ ) { int x; cin &gt;&gt; x; // scanf(&quot;%d&quot;, &amp;x); // tt确保栈不空，栈顶元素大于等于当前数，栈顶元素永远不会被用到，则删除/弹出该数 // 每次不符合都是直接减tt，最多减到0 // 这里维护的是一个单调递增的队列，且当前数是最大的，左侧第一个数一定第一个是最小的（由于上面的while循环） while (tt &amp;&amp; stk[tt] &gt;= x) tt -- ; // 完成之后如果栈不空，则该为符合条件的数 if (tt) cout &lt;&lt; stk[tt] &lt;&lt; ' '; // print(&quot;%d&quot;, stk[tt]); // 否则栈是空的，左边没有任何一个数比它小 else cout &lt;&lt; -1 &lt;&lt; ' '; // print(&quot;-1 &quot;); // 把x插入栈中 stk[ ++ tt] = x; } return 0;} 每个元素只会进栈一次出栈一次，加到一起也是O(2n)，所以时间复杂度就是O(n) 数据量大时用scanf，printf 2.1.3 模板2.2 单调队列2.2.1 模拟队列队列：先进先出 12345678910111213141516// hh队头 tt队尾 在队尾插入元素，在队头弹出元素int q[N], hh = 0, tt = -1; // tt等于0或-1都行// 插入q[ ++ tt] = x;// 弹出hh ++ ; // 队头指针往后移动一位// 判断队列是否为空if (hh &lt;= tt) not emptyelse empty// 取出队头、队尾元素q[hh]q[tt] 2.2.2 例题给定一个大小为n &lt;= 10^6^的数组。 有一个大小为k的滑动窗口，它从数组的最左边移动到最右边。 您只能在窗口中看到k个数字。 每次滑动窗口向右移动一个位置。 以下是一个例子： 该数组为[1 3 -1 -3 5 3 6 7]，k为3 窗口位置 最小值 最大值 [1 3 -1] -3 5 3 6 7 -1 3 1 [ 3 -1 -3 ] 5 3 6 7 -1 3 1 3 [ -1 -3 5 ] 3 6 7 -3 5 1 3 -1 [ -3 5 3 ] 6 7 -3 5 1 3 -1 -3 [ 5 3 6 ] 7 3 6 1 3 -1 -3 5 [ 3 6 7 ] 3 7 输入格式 输入包含两行。 第一行包含两个整数n和k，分别代表数组长度和滑动窗口的长度。 第二行有n个整数，代表数组的具体数值。 同行数据之间用空格隔开。 输出格式 输出包含两个。 第一行输出，从左至右，每个位置滑动窗口中的最小值。 第二行输出，从左至右，每个位置滑动窗口中的最大值。 输入样例： 128 31 3 -1 -3 5 3 6 7 输出样例： 12-1 -3 -3 -3 3 33 3 5 5 6 7 123456789101112131415161718192021222324252627282930313233343536373839404142#include &lt;iostream&gt;using namespace std;const int N = 1000010;int n, k;int a[N], q[N]; // a[N]存值，q[N]存下标int main(){ scanf(&quot;%d%d&quot;, &amp;n, &amp;k); for (int i = 0; i &lt; n; i ++ ) scanf(&quot;%d&quot;, &amp;a[i]); // 先把数都读进来 int hh = 0, tt = -1; for (int i = 0; i &lt; n; i ++ ) { // 判断队头是否已经滑出窗口 // hh &lt;= tt 不空，终点是i，则起点是(i - k + 1) // 若 i - k + 1 &gt; q[hh] 则说明队列头出了窗口 // 这里为什么不写 while? 因为窗口每次只会往后移动一位，所以队列里面最多只有一个数不在窗口内 if (hh &lt;= tt &amp;&amp; i - k + 1 &gt; q[hh]) hh ++ ; // 如果新插入的数，队尾比它大的话，则队尾没用，删掉 // 一种情况，如果队列一直是单调递增的(1 3 4 or 2 4 3)则最后输出的就是通过第一次q[ ++ tt]对q[0]赋的值(下标)，因为hh从未改变最也就是输出q[0] // 另一种情况(1 3 -1)则tt减到-1，重新构建递增队列，将tt减到-1，然后++tt，即tt = hh = 0，且对qq[0]赋当前最小数的下标 while (hh &lt;= tt &amp;&amp; a[q[tt]] &gt;= a[i]) tt -- ; // 如果要输出最大数，则只需改成 a[q[tt]] &lt;= a[i] // 因为i有可能是最小值，所以这个在前 // 1 3 -1，就是此种情况，如果赋值在后，则会输出一开始对q[0]赋的值(1的下标0) q[ ++ tt ] = i; // 从前k个数输出，不足k个不输出 // 关于输出a[q[hh]]，hh 和 tt 的关系，如上。hh始终是等于0，也是输出q[0]，递增队列的第一个数，也即最小的数 if (i &gt;= k - 1) printf(&quot;%d &quot;, a[q[hh]]); } puts(&quot;&quot;); return 0;} 3. kmpkmp算法其实就是先对模板串预处理，即求next数组，然后再据此把模式串和模板串匹配 求next数组过程 3.1 模板1234567891011121314151617181920// s[]是长文本，p[]是模式串，n是s的长度，m是p的长度求模式串的Next数组：for (int i = 2, j = 0; i &lt;= m; i ++ ){ while (j &amp;&amp; p[i] != p[j + 1]) j = ne[j]; if (p[i] == p[j + 1]) j ++ ; ne[i] = j;}// 匹配for (int i = 1, j = 0; i &lt;= n; i ++ ){ while (j &amp;&amp; s[i] != p[j + 1]) j = ne[j]; if (s[i] == p[j + 1]) j ++ ; if (j == m) { j = ne[j]; // 匹配成功后的逻辑 }} 3.2 例题给定一个模式串S，以及一个模板串P，所有字符串中只包含大小写英文字母以及阿拉伯数字。 模板串P在模式串S中多次作为字串出现。 求出模板串P在模式串S中所有出现的位置的起始下标。 输入格式 第一行输入整数N，表示字符串P的长度。 第二行输入字符串P。 第三行输入整数M，表示字符串S的长度。 第四行输入字符串M。 输出格式 共一行，输出所有出现位置的起始下标（下标从0开始计数），整数之间用空格隔开。 数据范围 1 &lt;= N &lt;= 10^4^1 &lt;= M &lt;= 10^5^ 输入样例： 12343aba5ababa 输出样例： 10 2 12345678910111213141516171819202122232425262728293031323334#include &lt;iostream&gt;using namespace std;const int N = 10010, M = 100010;int n, m;char p[N], s[N];int ne[N];int main(){ cin &gt;&gt; n &gt;&gt; p + 1 &gt;&gt; m &gt;&gt; s + 1; // 求next的过程 for (int i = 2, j = 0; i &lt;= n; i ++ ) { while (j &amp;&amp; p[i] != p[j + 1]) j = ne[j]; if (p[i] == p[j + 1]) j ++ ; ne[i] = j; } // kmp 匹配过程 for (int i = 1, j = 0; i &lt;= m; i ++ ) { while (j &amp;&amp; s[i] != p[j + 1]) j = ne[j]; if (s[i] == p[j + 1]) j ++ ; if (j == n) { printf(&quot;%d &quot;, i - n); j = ne[j]; } } } 3.2.1 时间复杂度时间复杂度O(n)比如在kmp比较过程中（二者一样）j每次最多加1。因为i循环m次，则j最多加m次又while循环中每执行一次j起码减1，最多减m次，while循环最多执行m次时间复杂度是O(2m) 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394#include &lt;iostream&gt;using namespace std;const int N = 10010, M = 100010;int n, m;char p[N], s[M];int ne[N];int main(){ cin &gt;&gt; n &gt;&gt; p + 1 &gt;&gt; m &gt;&gt; s + 1; cout &lt;&lt; &quot;模板串p[]=&quot; &lt;&lt; endl; for (int i = 0; i &lt;= 10; i ++ ) cout &lt;&lt; &quot;i：&quot; &lt;&lt; i &lt;&lt; &quot; &quot; &lt;&lt; p[i] &lt;&lt; &quot; &quot;; cout &lt;&lt; endl; cout &lt;&lt; &quot;模式串s[]=&quot; &lt;&lt; endl; for (int i = 0; i &lt;= 10; i ++ ) cout &lt;&lt; &quot;i：&quot; &lt;&lt; i &lt;&lt; &quot; &quot; &lt;&lt; s[i] &lt;&lt; &quot; &quot;;// 求 next 的过程// 是对模板串 p 的预处理// 纵向比较。i 和 j+1 比较，所以 i 从 2 开始，j 从 0 开始。求 next 过程的终止条件为遍历完模板串 p[] ，在本题中即 i=n=3 for (int i = 2, j = 0; i &lt;= n; i ++ ) {// j 没有退到起点，退到起点重新匹配 不然没这个条件的当 j = 0 的时候就死循环了// 只要 j 没有退回起点，并且当前的 p[i] 和 p[j+1] 不匹配的话就往后退。终止条件就是退到开始 j=0 或者 二者匹配成功 cout &lt;&lt; endl &lt;&lt; &quot;###&quot;; cout &lt;&lt; (bool)j &lt;&lt; &quot; &quot; &lt;&lt; (bool)(p[i] != p[j + 1]) &lt;&lt; endl; while (j &amp;&amp; p[i] != p[j + 1]) // 比较的是 j 不是 j+1 { cout &lt;&lt; &quot;wrong, j = &quot; &lt;&lt; j &lt;&lt; endl; j = ne[j]; cout &lt;&lt; &quot;update, j = &quot; &lt;&lt; j &lt;&lt; endl; }// 如果终止条件是已经匹配成功了，j 就移到下一位置 if (p[i] == p[j + 1]) { cout &lt;&lt; endl &lt;&lt; &quot;right, j = &quot; &lt;&lt; j &lt;&lt; &quot; &quot; &lt;&lt; &quot;i = &quot; &lt;&lt; i &lt;&lt; endl; j ++ ; // 只有当匹配成功的时候 j 才会增加 }// 将 j 计入 next 数组中，未成功也计入 ne[i] = j; // next[] 从 2 开始 } cout &lt;&lt; &quot;next[] = &quot; &lt;&lt; endl; for (int i = 0; i &lt; 9; i ++ ) cout &lt;&lt; ne[i] &lt;&lt; &quot; &quot; &lt;&lt; &quot;i：&quot; &lt;&lt; i &lt;&lt; &quot; &quot; &lt;&lt; endl;// kmp 匹配过程// 横向比较。i 和 j+1 比较，所以 i 从 1 开始，j 从 0 开始。kmp 匹配过程的终止条件为遍历完模式串 s[]，在本题中即 i=m=5 for (int i = 1, j = 0; i &lt;= m; i ++ ) {// 只要 j 没有退回起点，并且当前的 s[i] 和 p[j+1] 不匹配的话就往后退。终止条件就是退到开始 j=0 或者二者匹配成功 while (j &amp;&amp; s[i] != p[j + 1]) { cout &lt;&lt; &quot;j退至下一位置&quot; &lt;&lt; endl; j = ne[j]; }// 如果终止条件是已经匹配成功了，j 就移到下一位置 if (s[i] == p[j + 1]) { cout &lt;&lt; &quot;匹配成功，j+1&quot; &lt;&lt; endl; j ++ ; }// 如果 j 等于 n 则匹配成功。// 因为 n 是模板串的长度，j 每达到一次模板串的长度就说明整个模板串匹配成功一次，而只有匹配成功每个字符 j 才会加 1 if (j == n) { cout &lt;&lt; &quot;匹配成功时 i=&quot; &lt;&lt; i &lt;&lt; endl; printf(&quot;%d &quot;, i - n); // 本题要求输出匹配的起始位置，i 是模式串的指针 n 是模板串的长度 cout &lt;&lt; endl; j = ne[j]; // 匹配成功，j 退回至上一位置，即起点 } } return 0;}/* 8 abababab 7 abababc s[] = ababccab 测试 求next过程触发 while 循环 同时 kmp比较过程触发 while 循环的输入样例 5 ababc 9 ababcabac*/","link":"/2023/10/23/%E7%AE%97%E6%B3%95/04-%E9%93%BE%E8%A1%A8%E4%B8%8E%E9%82%BB%E6%8E%A5%E8%A1%A8-%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97-kmp/04-%E9%93%BE%E8%A1%A8%E4%B8%8E%E9%82%BB%E6%8E%A5%E8%A1%A8-%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97-kmp/"},{"title":"sdf","text":"1. This is a blog Test First Second","link":"/2023/11/08/sdf/"}],"tags":[{"name":"基础算法","slug":"基础算法","link":"/tags/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/"},{"name":"test","slug":"test","link":"/tags/test/"},{"name":"tag2","slug":"tag2","link":"/tags/tag2/"},{"name":"数据结构","slug":"数据结构","link":"/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"categories":[{"name":"算法","slug":"算法","link":"/categories/%E7%AE%97%E6%B3%95/"},{"name":"测试用的","slug":"测试用的","link":"/categories/%E6%B5%8B%E8%AF%95%E7%94%A8%E7%9A%84/"}],"pages":[]}